---
title: "Git 使用规范与技巧"
date: "2025-11-26"
updated: "2025-12-08"
description: "一份关于 Git 日常使用的实践指南，内容涵盖提交信息的规范、约定式提交、历史记录的修改与修正、Git Flow 工作流及语义化版本控制。"
category: "technology"
---

# Git 使用规范与技巧

## 提交信息 (Commit Message)

### 语言选择
提交信息的首要原则是清晰、易于理解。对于非国际化的项目团队，使用中文撰写提交信息可以有效提高团队成员及未来维护者的可读性。

### 约定式提交 (Conventional Commits)

约定式提交是一种标准化的提交信息格式，它有助于自动化生成 CHANGELOG、确定版本号，并使提交历史更具可读性。

**基本格式**：
```
<type>[optional scope]: <description>

[optional body]

[optional footer(s)]
```

**关键点**：

1.  **标题与正文分离**：
    提交信息的**第一个空行**之前的所有内容均被视作**标题**。详细描述应在标题后的空行之后撰写。

    *   **错误示例**：
        ```
        feat: 这是一个提交标题
        - 这部分内容依然被视为标题的一部分，并未成功换行。
        ```

    *   **正确示例**：
        ```
        feat: 实现用户认证功能
        
        - 详细描述认证流程。
        - 使用 JWT 进行令牌管理。
        ```

2.  **类型与描述间的空格**：
    在提交类型（如 `feat`, `fix`）后，必须跟一个冒号和一个空格。
    ```
    feat: <--(注意此处的空格) 添加新功能
    ```

3.  **合并提交 (Merge Commit)**：
    通常，由 `git merge` 或在 GitHub/GitLab 等平台上通过 PR/MR 自动生成的合并提交，无需严格遵守约定式提交格式，因为相关的详细变更已记录在被合并的各个独立提交中。

4.  **破坏性变更 (BREAKING CHANGE)**：
    在正文或页脚处使用 `BREAKING CHANGE:` 声明不兼容的 API 变更。即使在个人项目中，也应注意识别并标记此类变更。为了保证未来的可维护性

#### 常用提交类型 (Type)

| 变更内容                                  | 提交类型     | 备注                                     |
| ----------------------------------------- | ------------ | ---------------------------------------- |
| 影响构建系统或外部依赖的配置文件（如 `.gitignore`, `pnpm-workspace.yaml`） | chore        | 杂项，不涉及源码或测试文件的修改       |
| 影响生产环境构建流程的配置（如 `Dockerfile`, `webpack.config.js`） | build        | 专用于构建过程的变更                   |
| 增加或修改日志输出，用于调试或监控        | refactor/fix | 通常不属于用户可感知的新功能           |
| 大范围代码重构，但**未引入新功能或修复 Bug** | refactor     | 旨在改善代码结构、可读性或性能 |
| 引入一个新功能                             | feat         | -                                        |
| 修复一个 Bug                              | fix          | -                                        |
| 增加或修改文档                           | docs         | -                                        |
| 格式化代码，不影响逻辑                   | style        | -                                        |
| 增加或修改测试用例                       | test         | -                                        |


## 版本历史修改

Git 提供了强大的历史记录追溯与修改能力，这使得修正错误成为一个安全且可控的过程。

1.  **数据安全**：Git 的设计确保了几乎所有操作都是可恢复的。只要提交存在，代码就不会丢失。在执行不熟悉的操作前，创建分支或手动备份项目目录是额外的安全措施。
2.  **历史修改**：开发者可以自由地修改本地提交历史，以使其更加清晰和有逻辑。
3.  **远程仓库**：当需要更新远程仓库的历史时，可以使用强制推送。但在协作环境中，此操作需谨慎并与团队成员充分沟通。

### 常用修正方法

1.  **修正上一个提交** (`--amend`)
    如果需要向上一个提交中补充修改或仅修正提交信息，可使用此命令：
    ```bash
    # 将暂存区的修改合并到上一个提交
    git commit --amend

    # 如果只想修改提交信息，而不添加新修改
    git commit --amend --no-edit # (保留原信息) 或直接进入编辑器修改
    ```

2.  **撤销操作** (`reflog` & `reset`)
    `git reflog` 会列出 `HEAD` 的所有历史变动记录。这是一个强大的恢复工具。
    ```bash
    # 1. 查看操作日志
    git reflog
    
    # 2. 找到目标状态的引用，如 HEAD@{n}
    
    # 3. 恢复到指定状态，并保留工作区的修改
    git reset HEAD@{n}
    
    # 4. 如果希望彻底丢弃指定状态之后的所有修改
    git reset --hard HEAD@{n}
    ```
    > **快捷方式**：
    > 在执行了一次危险操作（如 `rebase` 或 `merge`）后，`ORIG_HEAD` 指针会记录操作前的位置。可以使用以下命令快速撤销：
    > ```bash
    > git reset --hard ORIG_HEAD
    > ```

3.  **交互式变基** (`rebase -i`)
    交互式变基允许你自由地修改一系列提交，例如重新排序、合并、拆分或修改提交信息。

    首先，找到你想修改的系列提交的**上一个**提交的哈希值。
    ```bash
    git rebase -i <commit_hash>
    ```
    > **处理包含合并提交的分支**：
    > 若要在一个包含合并提交的分支上进行变基，并希望保留这些合并结构，需使用 `-r` 或 `--rebase-merges` 选项。
    > ```bash
    > git rebase -i -r <commit_hash>
    > ```
    > 需要注意的是，交互式变基无法直接编辑一个合并提交本身。若合并提交引入问题，更稳妥的策略是撤销合并，在源分支修复问题后，再重新执行合并。

    执行命令后，Git 会打开一个编辑器窗口，其中列出了指定哈希之后的所有提交：
    ```
    pick <hash1> commit_message_1
    pick <hash2> commit_message_2
    ```
    通过修改每个提交前的命令 (`pick`)，可以执行不同操作（命令可简写为首字母）：
    - `pick` (`p`): 保留该提交，不做改变。
    - `reword` (`r`): 保留提交内容，但暂停以修改提交信息。
    - `edit` (`e`): 暂停以修改提交内容（例如拆分提交、添加新文件等）。
    - `squash` (`s`): 将该提交合并到前一个提交中，并合并提交信息。
    - `fixup` (`f`): 同 `squash`，但丢弃该提交的提交信息。
    - `drop` (`d`): 删除该提交。

    > **注意**：
    > - 变基是通过在新的基底上**重新应用**提交来工作的，这会改变提交的哈希值。因此，任何指向旧提交的标签（tag）都会失效。
    > - `edit` 操作会更新提交的作者和提交日期。如果只想修改提交信息，应优先使用 `reword`。

    完成编辑后，保存文件并关闭编辑器。Git 会根据你的指令执行变基。如果遇到暂停（如 `edit` 或 `reword`），完成修改后，使用以下命令继续：
    ```bash
    git rebase --continue
    ```

### 强制推送 (`push -f`)

当本地分支的历史与远程分支产生分歧（例如，在 `rebase` 或 `amend` 之后），需要使用强制推送来更新远程分支。
```bash
git push --force-with-lease origin <branch_name>
```
> **安全警告**：
> - **强烈推荐使用 `--force-with-lease`** 而不是 `-f` 或 `--force`。它会在推送前检查远程分支是否被他人更新，从而避免意外覆盖他人的工作。
> - 在团队协作中，**禁止**向共享分支（如 `main` 或 `develop`）强制推送，除非已与所有相关成员达成一致。更好的做法是通过一个新的提交来修正错误。

## Git Flow 工作流

Git Flow 是一种成熟的分支管理模型。尽管其完整的命令行工具 `git-flow` 已不再是 Git for Windows 的默认组件（有需要的用户可查找历史版本或替代方案），其核心思想仍极具价值。

一个简化的、适合多数项目的专业工作流如下：
1.  `main` 分支作为稳定的生产版本，只接受来自 `develop` 或 `hotfix` 分支的合并。
2.  `develop` 分支作为主要的开发集成分支，所有新功能都在此汇集。
3.  **功能开发**：从 `develop` 创建 `feature/` 分支进行新功能开发。完成后，通过 Pull Request (PR) / Merge Request (MR) 合并回 `develop`。
4.  **发布准备**：当 `develop` 分支达到一个可发布的稳定状态时，可创建 `release/` 分支进行最后的测试和版本号管理。完成后，合并到 `main` 和 `develop`。
5.  **热修复**：当线上 `main` 分支出现紧急 Bug 时，从 `main` 创建 `hotfix/` 分支进行修复，完成后同样合并到 `main` 和 `develop`。

> 使用 Pull Request 是一个关键实践。它为代码审查、自动化测试和团队讨论提供了一个正式的平台，确保了 `main` 分支的代码质量。即使是个人项目，遵循此流程也有助于养成良好习惯。

## 语义化版本控制 (SemVer)

语义化版本控制（SemVer）是一个通过版本号 `MAJOR.MINOR.PATCH` 来传达变更内容的规范。

- **MAJOR** (主版本号): 当你做了不兼容的 API 修改。
- **MINOR** (次版本号): 当你做了向下兼容的功能性新增。
- **PATCH** (修订号): 当你做了向下兼容的问题修正。

为 `main` 分支的每个重要节点（尤其是发布）打上版本号标签，是一种优秀的实践。这不仅使项目历史清晰可追溯，也为依赖管理和发布自动化提供了坚实基础。不仅如此，这也会给初学者带来极大的成就感。
```bash
# 为当前 commit 创建一个轻量标签
git tag v1.0.1

# 推送标签到远程仓库
git push origin v1.0.1
```